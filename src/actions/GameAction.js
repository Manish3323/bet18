import { LOAD_GAMES, SELECT_GAME, GROUPS_URL, TEAMS_URL, LOAD_TEAMS, AWAY_SCORE_CHANGED, PREDICTIONS_URL, HOME_SCORE_CHANGED, USERS_URL, LOAD_PREDICTIONS, SET_CURRENT_GROUPID, LOADING, LOAD_USERS, FINISHED_MATCHES_URL, UPDATE_POINTS_TO_PREDICTION, LIVE_DATA, PAST_DATA, FUTURE_DATA, SELECT_CURRENT_MATCH, NO_CURRENT_MATCHES } from './types'
import firebase from 'firebase'
import { ObjectsToArray, convertDateTimeToDate, getCurrentTime } from '../Utility'
import { Alert } from 'react-native'
/**
 * @desc fetch games either for a group or a specific game by passing both matchid and groupid
 * @param {groupCode} groupCode e.g Group a,b,c...g
 * @param {matchId} matchId e.g unique match id for each match to be played in worldcup
 * @returns array of matches containing object(s)
 * @desc returned object will have following properties
 * @desc matchid,homeTeam,awayTeam,date,finished,stadium,type
 */
export const loadGames = ({groupCode, matchId}) => {
  let url = GROUPS_URL
  if (groupCode !== '') {
    url = url + '/' + groupCode
  } else if (groupCode !== '' && matchId !== '') {
    url = url + '/' + groupCode + '/' + matchId
  }
  return (dispatch) => {
    firebase.database().ref(url)
      .on('value', (snapshot) => {
        let array = ObjectsToArray(snapshot.val())
        dispatch({type: LOADING})
        dispatch({type: LOAD_GAMES, payload: array})
      })
  }
}
/**
 * @desc fetchs all the 32 particiating teams in the world cup
 * @desc returned list will contain 32 objects
 * @desc each object will have following properties
 * @desc id=[1,2,3,...],iso=['sa','ru','ar',....],name=['saudi arabia','russia','argentina',....]
 */
export const loadTeams = () => {
  let url = TEAMS_URL
  return (dispatch) => {
    firebase.database().ref(url)
      .on('value', (snapshot) => {
        let array = ObjectsToArray(snapshot.val())
        dispatch({type: LOADING})
        dispatch({type: LOAD_TEAMS, payload: array})
      })
  }
}
/**
  * @desc this action is called when a single match is selected
  * @desc which updates the redux store having Game.selectedGame property
*/
export const selectGame = (match, groupCode) => {
  return {
    type: SELECT_GAME,
    payload: {match: match, groupCode: groupCode}
  }
}

/**
 * @desc loads all the previous predictions for the current user
 * @desc and continous watching over the /users/${uid}/predictions path for any insertion or updation at this path
 * @desc and updates the redux store Game.predictions propterty for the current loggedin user
 */
export const loadPredictions = () => {
  const user = firebase.auth().currentUser
  let url = USERS_URL + '/' + user.uid + PREDICTIONS_URL
  return (dispatch) => {
    firebase.database().ref(url)
      .on('value', (snapshot) => {
        let array = ObjectsToArray(snapshot.val())
        dispatch({type: LOADING})
        dispatch({type: LOAD_PREDICTIONS, payload: array})
      })
  }
}
/**
 *
 * @param {Score of Home Team} text
 * @desc updates the redux store
 */
export const homeScoreChange = (text) => {
  return {
    type: HOME_SCORE_CHANGED,
    payload: text
  }
}
/**
 *
 * @param {Score of Away Team} text
 * @desc updates the redux store
 */
export const awayScoreChange = (text) => {
  return {
    type: AWAY_SCORE_CHANGED,
    payload: text
  }
}
/**
 *
 * @desc updates the previous prediction by the passed params on firebase databasse
 * @desc /users/${uid}/predictions/${predictionkey} this path is updated
 * @param matchId string - the match on which the prediction is made
 * @param homeScore string - predicted score for home team
 * @param awayScore string - predicted score for away team
 * @param predictionKey string - unique key generated by firebase for each prediction path  for e.g : /users/${uid}/predictions/${predictionkey}
 */
export const updatePrediction = (matchId, homeScore, awayScore, predictionKey, groupCode, homeTeam, awayTeam) => {
  if (homeScore && awayScore) {
    return (dispatch) => {
      const user = firebase.auth().currentUser
      let url = USERS_URL + '/' + user.uid + PREDICTIONS_URL + '/' + predictionKey
      const currentTime = convertDateTimeToDate(getCurrentTime(), 'DD/MM/YYYY HH:mm:ss')
      firebase.database().ref(url)
        .update({
          uid: user.uid,
          matchId: matchId,
          homeScore: homeScore,
          awayScore: awayScore,
          groupCode: groupCode,
          homeTeam: homeTeam,
          awayTeam: awayTeam,
          userEmail: user.email,
          predictionTime: currentTime
        }, (data) => {
          Alert.alert('Saved')
        })
    }
  } else {
    return (dispatch) => {
      Alert.alert('No data entered')
    }
  }
}
/**
 *
 * @desc store the previous prediction by the passed params on firebase database
 * @desc /users/${uid}/predictions this path is updated
 * @param matchId string - the match on which the prediction is made
 * @param homeScore string - predicted score for home team
 * @param awayScore string - predicted score for away team
 * @desc predictionKey string - TO BE USED WHILE UPDATING or FETCHING predictions - unique key generated by firebase for each prediction path  for e.g : /users/${uid}/predictions/${predictionkey}
 */
export const savePrediction = (matchId, homeScore, awayScore, groupCode, homeTeam, awayTeam) => {
  if (homeScore && awayScore) {
    return (dispatch) => {
      const user = firebase.auth().currentUser
      let url = USERS_URL + '/' + user.uid + PREDICTIONS_URL
      const currentTime = convertDateTimeToDate(getCurrentTime, 'DD/MM/YYYY HH:mm:ss')
      firebase.database().ref(url)
        .push({
          uid: user.uid,
          matchId: matchId,
          homeScore: homeScore,
          awayScore: awayScore,
          groupCode: groupCode,
          homeTeam: homeTeam,
          awayTeam: awayTeam,
          userEmail: user.email,
          predictionTime: currentTime
        }, (data) => {
          Alert.alert('Saved')
        })
    }
  } else {
    return (dispatch) => {
      Alert.alert('Type Valid Scores')
    }
  }
}

export const selectGroupCode = (groupCode) => {
  return {
    type: SET_CURRENT_GROUPID,
    payload: groupCode
  }
}

export const loadUsers = () => {
  const url = USERS_URL
  return (dispatch) => {
    firebase.database().ref(url).on('value', (snapshot) => {
      let array = ObjectsToArray(snapshot.val())
      // array = orderBykey(array, '', 'desc')
      dispatch({type: LOADING})
      dispatch({type: LOAD_USERS, payload: array})
    })
  }
}
// /**
//  * @description calculates points for finished matches on which user had predicted
//  * @description updates prediction with no points if match is not finished
//  * @description updates prediction with calculated points if it is finished.
//  */
// export function calculatePoints () {
//   const currentUser = firebase.auth().currentUser
//   const url = USERS_URL + '/' + currentUser.uid + PREDICTIONS_URL
//   const finishedMatchesurl = FINISHED_MATCHES_URL  // must have a property named 'level' in each object
//   return (dispatch) => {
//     dispatch({type: LOADING})
//     firebase.database().ref(finishedMatchesurl).once('value', (snapshot) => {
//       const matches = ObjectsToArray(snapshot.val())
//       firebase.database().ref(url).once('value', (snapshot) => {
//         let predictionsArray = ObjectsToArray(snapshot.val())
//         let updatedPredictions = predictionsArray.map((prediction) => {
//           return matches.map((match) => {
//             if (match.matchId === prediction.matchId) {
//               let points = generatePoints({prediction, match})
//               let weightedPoints = points * weightOfMatch({match, points})
//               return {...prediction, weightedPoints, points}
//             } else {
//               return prediction
//             }
//           })[0]
//         })
//         dispatch({type: UPDATE_POINTS_TO_PREDICTION, payload: updatedPredictions})
//       })
//     })
//   }
// }

/**
 * @description setting live data feed on load of grouplist page to state.Game object
 * @param {*} data
 */
export const setLiveData = (data) => {
  if (data === NO_CURRENT_MATCHES) {
    return (dispatch) => {
      dispatch({type: NO_CURRENT_MATCHES, payload: NO_CURRENT_MATCHES})
    }
  } else {
    return (dispatch) => {
      dispatch({type: LOADING})
      dispatch({type: LIVE_DATA, payload: data})
    }
  }
}
/**
 * @description setting future data feed on load of grouplist page to state.Game object
 * @param {*} data
 */
export const setFutureData = (data) => {
  return (dispatch) => {
    dispatch({type: LOADING})
    dispatch({type: FUTURE_DATA, payload: data})
  }
}
/**
 * @description setting PAST data feed on load of grouplist page to state.Game object
 * @param {*} data
 */
export const setPastData = (data) => {
  return (dispatch) => {
    dispatch({type: LOADING})
    dispatch({type: PAST_DATA, payload: data})
  }
}

export const selectCurrentMatch = (match) => {
  return {
    type: SELECT_CURRENT_MATCH,
    payload: match
  }
}
